<span id="page-0-0"></span>Daniel Ho 1 2 Eric Liang <sup>1</sup> Ion Stoica <sup>1</sup> Pieter Abbeel 1 3 Xi Chen 1 3

# Abstract

A key challenge in leveraging data augmentation for neural network training is choosing an effective augmentation policy from a large search space of candidate operations. Properly chosen augmentation policies can lead to significant generalization improvements; however, state-of-theart approaches such as AutoAugment are computationally infeasible to run for the ordinary user. In this paper, we introduce a new data augmentation algorithm, *Population Based Augmentation* (PBA), which generates nonstationary augmentation policy schedules instead of a fixed augmentation policy. We show that PBA can match the performance of AutoAugment on CIFAR-10, CIFAR-100, and SVHN, with three orders of magnitude less overall compute. On CIFAR-10 we achieve a mean test error of 1.46%, which is a slight improvement upon the current state-of-the-art. The code for PBA is open source and is available at <https://github.com/arcelien/pba>.

# 1. Introduction

Data augmentation techniques such as cropping, translation, and horizontal flipping are commonly used to train large neural networks [\(Lin et al.,](#page-9-0) [2013\)](#page-9-0). Augmentation transforms images to increase the diversity of image data. While deep neural networks can be trained on enormous numbers of data examples to exhibit excellent performance on tasks such as image classification, they contain a likewise enormous number of parameters, which causes overfitting. Data augmentation acts as a regularizer to combat this. However, most approaches used in training state-of-the-art networks only use basic types of augmentation. While neural network

![](_page_0_Figure_8.jpeg)

**Caption:** Figure 1 illustrates the performance of Population Based Augmentation (PBA) compared to AutoAugment across various neural network architectures on the CIFAR-10 dataset. PBA achieves similar classification accuracy while requiring significantly less computational resources, demonstrating its efficiency in data augmentation policy learning.

Figure 1. PBA matches AutoAugment's classification accuracy across a range of different network models on the CIFAR-10 dataset, while requiring 1,000x less GPU hours to run. For the full set of results, refer to Table [2.](#page-5-0) Assuming an hourly GPU cost of \$1.5, producing a new augmentation policy costs around \$7.5 for PBA vs \$7,500 with AutoAugment. The same scaling holds for the SVHN dataset as well.

architectures have been investigated in depth [\(Krizhevsky](#page-9-0) [et al.,](#page-9-0) [2012;](#page-9-0) [He et al.,](#page-8-0) [2015;](#page-8-0) [Szegedy et al.,](#page-9-0) [2015;](#page-9-0) [Simonyan](#page-9-0) [& Zisserman,](#page-9-0) [2014;](#page-9-0) [Zagoruyko & Komodakis,](#page-10-0) [2016;](#page-10-0) [Huang](#page-8-0) [et al.,](#page-8-0) [2016;](#page-8-0) [Han et al.,](#page-8-0) [2016\)](#page-8-0), less focus has been put into discovering strong types of data augmentation and data augmentation policies that capture data invariances.

A key consideration when applying data augmentation is picking a good set of augmentation functions, since redundant or overly aggressive augmentation can slow down training and introduce biases into the dataset [\(Graham,](#page-8-0) [2014\)](#page-8-0). Many recent methods learn augmentation policies to apply different functions to image data. Among these, AutoAugment [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0) stands out with state-of-theart results in CIFAR-10 [\(Krizhevsky,](#page-8-0) [2009\)](#page-8-0), CIFAR-100 [\(Krizhevsky,](#page-8-0) [2009\)](#page-8-0), and ImageNet [\(Deng et al.,](#page-8-0) [2009\)](#page-8-0). Using a method inspired by Neural Architecture Search [\(Zoph](#page-10-0) [& Le,](#page-10-0) [2016\)](#page-10-0), Cubuk et al. learn a distilled list of augmentation functions and associated probability-magnitude values, resulting in a distribution of possible augmentations which can be applied to each batch of data. However, the search technique used in the work is very computationally expensive, and code has not been released to reproduce it. In this work, we address these issues with a simple and efficient algorithm for augmentation policy learning.

<sup>1</sup>EECS, UC Berkeley, Berkeley, California, USA <sup>2</sup>Current affiliation: X, Mountain View, California, USA <sup>3</sup> covariant.ai, Berkeley, California, USA. Correspondence to: Daniel Ho <daniel.ho@berkeley.edu>.

*Proceedings of the* 36 th *International Conference on Machine Learning*, Long Beach, California, PMLR 97, 2019. Copyright 2019 by the author(s).

Table 1. Comparison of pre-computation costs and test set error (%) between this paper, AutoAugment (AA), and the previous best published results. Previous results did not pre-compute augmentation policies. AutoAugment reported estimated cost in Tesla P100 GPU hours, while PBA measured cost in Titan XP GPU hours. Besides PBA, all metrics are cited from [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0). For more detail, see Table [2.](#page-5-0) \*CIFAR-100 models are trained with the policies learned on CIFAR-10 data.

| Dataset   | Value      | Previous Best | AA   | PBA  |
|-----------|------------|---------------|------|------|
| CIFAR-10  | GPU Hours  | -             | 5000 | 5    |
|           | Test Error | 2.1           | 1.48 | 1.46 |
| CIFAR-100 | GPU Hours  | -             | 0*   | 0*   |
|           | Test Error | 12.2          | 10.7 | 10.9 |
| SVHN      | GPU Hours  | -             | 1000 | 1    |
|           | Test Error | 1.3           | 1.0  | 1.1  |

Our formulation of data augmentation policy search, Population Based Augmentation (PBA), reaches similar levels of final performance on a variety of neural network models while utilizing orders of magnitude less compute. We learn a robust augmentation policy on CIFAR-10 data in five hours using one NVIDIA Titan XP GPU, and we visualize its performance in Figure [1.](#page-0-0) Relative to the several days it takes to train large CIFAR-10 networks to convergence, the cost of running PBA beforehand is marginal and significantly enhances results. These results are summarized in Table 1. PBA leverages the Population Based Training algorithm [\(Jaderberg et al.,](#page-8-0) [2017\)](#page-8-0) to generate an augmentation *schedule* that defines the best augmentation policy for each epoch of training. This is in contrast to a fixed augmentation policy that applies the same transformations independent of the current epoch number.

We release code to run and evaluate our augmentation search algorithm at [https://github.com/](https://github.com/arcelien/pba) [arcelien/pba](https://github.com/arcelien/pba). This allows an ordinary workstation user to easily experiment with the search algorithm and augmentation operations. A particularly interesting use case would be to introduce new augmentation operations, perhaps targeted towards a particular dataset or image modality, and be able to quickly produce a tailored, high performing augmentation schedule. Our code uses the Ray [\(Moritz](#page-9-0) [et al.,](#page-9-0) [2017\)](#page-9-0) implementation of PBT, which allows for easy parallelization across and within GPUs and CPUs.

This paper is organized as follows: First, we cover relevant background and AutoAugment (Section 2). We then introduce the PBA algorithm (Section [3\)](#page-2-0). We describe the augmentation schedules PBA discovers and its performance on several datasets. Finally, we seek to understand the efficiency gains of PBA through ablation studies and comparison with baseline methods (Section [4\)](#page-4-0).

# 2. Background

## 2.1. Related Work

We first review types of data augmentation for image recognition, which improve generalization with limited data by applying transformations to generate additional samples. Common techniques such as random cropping, flipping, rotating, scaling, and translating are used by top performing models for training on MINST, CIFAR-10, and ImageNet datasets [\(Simard et al.,](#page-9-0) [2003;](#page-9-0) [Ciresan et al.,](#page-8-0) [2012;](#page-8-0) [Wan et al.,](#page-9-0) [2013;](#page-9-0) [Sato et al.,](#page-9-0) [2015;](#page-9-0) [Krizhevsky et al.,](#page-9-0) [2012;](#page-9-0) [Lin et al.,](#page-9-0) [2013;](#page-9-0) [Han et al.,](#page-8-0) [2016\)](#page-8-0). Some additional approaches to generate augmented data include image combining [\(Inoue,](#page-8-0) [2018;](#page-8-0) [Okafor et al.,](#page-9-0) [2018\)](#page-9-0), elastic distortions [\(Wong et al.,](#page-9-0) [2016\)](#page-9-0), and generative adversarial networks [\(Antoniou et al.,](#page-8-0) [2017\)](#page-8-0).

Augmentation has been shown to have a large impact on image modalities where data is scare or expensive to generate, like medical imaging [\(Bowles et al.,](#page-8-0) [2018;](#page-8-0) [Frid-Adar et al.,](#page-8-0) [2018\)](#page-8-0) or non-supervised learning approaches [\(Mundhenk](#page-9-0) [et al.,](#page-9-0) [2017\)](#page-9-0).

Several papers have attempted to automate the generation of data augmentations with data-driven learning. These use methods such as manifold learning [\(Paschali et al.,](#page-9-0) [2019\)](#page-9-0), Bayesian Optimization [\(Tran et al.,](#page-9-0) [2017\)](#page-9-0), and generative adversarial networks which generate transformation sequences [\(Ratner et al.,](#page-9-0) [2017\)](#page-9-0). Additionally, [\(Lemley et al.,](#page-9-0) [2017\)](#page-9-0) uses a network to combine pairs of images to train a target network, and [\(DeVries & Taylor,](#page-8-0) [2017\)](#page-8-0) injects noise and interpolates images in an autoencoder learned feature space. AutoAugment [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0) uses reinforcement learning to optimize for accuracy in a discrete search space of augmentation policies.

Our approach was inspired by work in hyperparameter optimization. There has been much previous work to welltune hyperparameters, especially in Bayesian Optimization [\(Srinivas et al.,](#page-9-0) [2009;](#page-9-0) [Bergstra et al.,](#page-8-0) [2011;](#page-8-0) [Snoek](#page-9-0) [et al.,](#page-9-0) [2012;](#page-9-0) [Hutter et al.,](#page-8-0) [2011\)](#page-8-0), which are sequential in nature and expensive computationally. Other methods incorporate parallelization or use non-bayesian techniques [\(Li et al.,](#page-9-0) [2016;](#page-9-0) [Golovin et al.,](#page-8-0) [2017;](#page-8-0) [Shah & Ghahramani,](#page-9-0) [2015;](#page-9-0) [Springenberg et al.,](#page-9-0) [2016;](#page-9-0) [Gonzalez et al.](#page-8-0) ´ , [2016\)](#page-8-0) but still either require multiple rounds of optimization or large amounts of compute. These issues are resolved in Population Based Training [\(Jaderberg et al.,](#page-8-0) [2017\)](#page-8-0), which builds upon both evolutionary strategies [\(Clune et al.,](#page-8-0) [2008\)](#page-8-0) and random search [\(Bergstra & Bengio,](#page-8-0) [2012\)](#page-8-0) to generate nonstationary, adaptive hyperparameter schedules in a single round of model training.

<span id="page-2-0"></span>![](_page_2_Figure_1.jpeg)

**Caption:** Figure 2 contrasts the augmentation strategies of AutoAugment and PBA. PBA utilizes a dynamic schedule for augmentation functions, optimizing them in conjunction with model training, while AutoAugment relies on a fixed set of policies, highlighting PBA's adaptability and efficiency in learning augmentation policies.

Figure 2. Comparison of AutoAugment and PBA augmentation strategies. In contrast to AutoAugment, PBA learns a schedule instead of a fixed policy. It does so in a short amount of time by using the PBT algorithm to jointly optimize augmentation policy parameters with the child model. PBA generates a single augmentation function f(x, t) where x is an input image and t the current epoch, compared to AutoAugment's ensemble of augmentation policies f i (x), each of which has several further sub-policies.

### 2.2. AutoAugment

Cubuk et al. shows that using a diverse, stochastic mix of augmentation operations can significantly reduce generalization error. They automate the search over the space of data augmentation policies in a method called AutoAugment, which significantly improves neural network model accuracy on a variety of image datasets. AutoAugment follows an approach similar to work in the neural architecture search area [\(Zoph et al.,](#page-10-0) [2017;](#page-10-0) [Pham et al.,](#page-9-0) [2018\)](#page-9-0) where a controller RNN network is trained via reinforcement learning to output augmentation policies maximizing for accuracy (Figure 2). However, this approach is expensive in both time and compute, as the signal for the controller has to be generated by training thousands of models to convergence on different augmentation policies and evaluating final validation accuracy.

Cubuk et al. curated an augmentation policy search space based on operations from the PIL python library. These include ShearX/Y, TranslateX/Y, Rotate, AutoContrast, Invert, Equalize, Solarize, Posterize, Contrast, Color, Brightness, Sharpness, Cutout [\(Devries & Taylor,](#page-8-0) [2017\)](#page-8-0), and Sample-Pairing [\(Inoue,](#page-8-0) [2018\)](#page-8-0). Each operation has two associated parameters: probability and magnitude. The authors used discrete probability values from 0% to 100%, in increments of 10%. Magnitude can range from 0 to 9 inclusive, but a few operations ignore this value and apply a constant effect.

Figure 3. Augmentations applied to a CIFAR-10 "car" class image, at various points in our augmentation schedule learned on Reduced CIFAR-10 data. The maximum number of operations applied is sampled from 0 to 2. Each operation is formatted with name, probability, and magnitude value respectively.

A policy would then consist of five sub-policies, each consisting of two operations and associated parameters. For every batch of data, one randomly selected sub-policy would be applied. In total, the final policy for AutoAugment concatenated the five best performing polices for a total of 25 sub-policies.

To learn an augmentation policy, 15,000 sampled policies were evaluated on a Wide-ResNet-40-2 (40 layers, widening factor of 2) child model [\(Zagoruyko & Komodakis,](#page-10-0) [2016\)](#page-10-0) by taking the validation accuracy after training for 120 epochs on a "reduced" dataset. For CIFAR-10, this consists of 4,000 images from the training set, and for SVHN, 1,000 images. CIFAR-100 is trained with a transferred augmentation policy from CIFAR-10.

# 3. Population Based Augmentation

In this section we introduce the design and implementation of the PBA algorithm.

### 3.1. Why Augmentation Schedules?

The end goal of PBA is to learn a schedule of augmentation policies as opposed to a fixed policy. As we will see, this choice is responsible for much of the efficiency gains of PBA (Section [4\)](#page-4-0). Though the search space for schedules over training epochs is larger than that of fixed policies f ∈ F by a factor of |F| |epochs| , counter-intuitively, PBA shows that it is far more efficient to search for a good schedule than a <span id="page-3-0"></span>fixed policy. Several factors contribute to this.

First, estimating the final test error of a fixed augmentation policy is difficult without running the training of a child model to completion. This is true in particular because the choice of regularizing hyperparameters (e.g., data augmentation functions) primarily impacts the tail end of training. Therefore, estimating the final performance of a given fixed augmentation policy requires training a model almost to completion. In contrast, it is straightforward to reuse prior computations to estimate the performance of two variants of a schedule that share a prefix.

Second, there is reason to believe that it is easier to find a good augmentation policy when searching in the space of schedules. An augmentation function that can reduce generalization error at the end of training is not necessarily a good function at initial phases. Such functions would be selected out when holding the augmentation function fixed for the entirely of training. And though the space of schedules is large, most good schedules are necessarily *smooth* and hence easily discoverable through evolutionary search algorithms such as PBT.

## 3.2. Learning a Schedule

In PBA we consider the augmentation policy search problem as a special case of hyperparameter schedule learning. Thus, we leverage Population Based Training (PBT) [\(Jaderberg](#page-8-0) [et al.,](#page-8-0) [2017\)](#page-8-0): a hyperparameter search algorithm which optimizes the parameters of a network *jointly* with their hyperparameters to maximize performance. The output of PBT is not an optimal hyperparameter configuration but rather a trained model and schedule of hyperparameters. In PBA, we are only interested in the learned schedule and discard the child model result (similar to AutoAugment). This learned augmentation schedule can then be used to improve the training of different (i.e., larger and costlier to train) models on the same dataset.

PBT executes as follows. To start, a fixed population of models are randomly initialized and trained in parallel. At certain intervals, an "exploit-and-explore" procedure is applied to the worse performing population members, where the model clones the weights of a better performing model (i.e., exploitation) and then perturbs the hyperparameters of the cloned model to search in the hyperparameter space (i.e., exploration). Because the weights of the models are cloned and never reinitialized, the total computation required is the computation to train a single model times the population size.

The Ray framework [\(Moritz et al.,](#page-9-0) [2017\)](#page-9-0) includes a parallelized implementation of PBT ([https://ray.](https://ray.readthedocs.io/en/latest/tune.html) [readthedocs.io/en/latest/tune.html](https://ray.readthedocs.io/en/latest/tune.html)) which handles the exploit-and-explore process in the backend. This

Algorithm 1 The PBA augmentation policy template, the parameters of which are optimized by PBT. The parameter vector is a vector of (op, prob, mag) tuples. There are two instances of each op in the vector, and this parameter cannot be changed. PBT learns a schedule for the prob and mag parameters during the course of training a population of child models.

Input: data x, parameters p, [list of (op, prob, mag)] Shuffle parameters Set count = [0, 1, 2] with probability [0.2, 0.3, 0.5] for (op, prob, mag) in p do if count = 0 then break end if if random(0, 1) < prob then count = count − 1 x = op(x, mag) end if end for Return x

implementation allows a user to deploy multiple trials on the same GPU, provided there is enough GPU memory. When the models only require a fraction of the computation resources and memory of an entire GPU, as in this work, training is sped up by fully utilizing the GPU.

## 3.3. Policy Search Space

In Algorithm 1, we describe the augmentation policy function used in PBA and the optimization strategy we adapt from PBT. The challenge here is defining a smooth parameterization of the augmentation policy so that PBT can incrementally adopt good augmentations, while still allowing good coverage of the search space within a limited number of perturbations.

To make PBA more directly comparable with AutoAugment, we attempt to preserve the qualities of the AutoAugment formulation when possible, using the same augmentation functions, a similar number of total augmentation functions in the policy, and the same set of magnitude variants per function as applicable. Our augmentation policy search space consists of the augmentation operations from AutoAugment, less SamplePairing [\(Inoue,](#page-8-0) [2018\)](#page-8-0), for a total of 15 operations. We use the same code and magnitude options derived from PIL operations to ensure a fair comparison based on search algorithm performance.

We define a set of hyperparameters consisting of two magnitude and probability values for each operation, with discrete possibilities for each. This gives us 30 operation-magnitudeprobability tuples for a total of 60 hyperparameters. Like AutoAugment, we have 10 possibilities for magnitude and

<span id="page-4-0"></span>Algorithm 2 The PBA explore function. Probability parameters have possible values from 0% to 100% in increments of 10%, and magnitdue parameters have values from 0 to 9 inclusive.

Input: Params p, list of augmentation hyperparameters for param in p do

```
if random(0, 1) < 0.2 then
    Resample param uniformly from domain
  else
    amt = [0,1,2,3] uniformly at random
    if random(0, 1) < 0.5 then
       param = param + amt
    else
       param = param − amt
    end if
    Clip param to stay in domain
  end if
end for
```
11 possibilities for probability. When we apply augmentations to data, we first shuffle all operations and then apply operations in turn until a limit is reached. This limit can range from 0 to 2 operations.

Similar to the AutoAugment policy, PBA allows for two of the same augmentation operations to be applied to a single batch of data. Due to the use of a schedule, a single operation the PBA search space includes (10 × 11)<sup>30</sup> ≈ 1.75 × 10<sup>61</sup> possibilities, compared to 2.8 × 10<sup>32</sup> for AutoAugment. For discussion about the hyperparameter priors encoded within this policy template, see Section [4.3.](#page-7-0) Our policy template formulation is primarily motivated by the need to directly compare results with AutoAugment rather than optimizing for the best possible policy template.

# 3.4. PBA Implementation

We describe the formulation of our search in the format of PBT experiments [\(Jaderberg et al.,](#page-8-0) [2017\)](#page-8-0).

Step: In each iteration we run an epoch of gradient descent.

Eval: We evaluate a trial on a validation set not used for PBT training and disjoint from the final test set.

Ready: A trial is ready to go through the exploit-andexplore process once 3 steps/epochs have elapsed.

Exploit: We use Truncation Selection [\(Jaderberg et al.,](#page-8-0) [2017\)](#page-8-0), where a trial in the bottom 25% of the population clones the weights and hyperparameters of a model in the top 25%.

Explore: See Algorithm 2 for the exploration function. For each hyperparameter, we either uniformly resample from all possible values or perturb the original value.

# 4. Experiments and Analysis

In this section, we describe experiments we ran to better understand the performance and characteristics of the PBA algorithm. We seek to answer the following questions:

- 1. How does classification accuracy and computational cost of PBA compare to state-of-the-art and random search baselines?
- 2. Where does the performance gain of PBA come from does having a schedule of augmentations really matter, or is a stationary distribution sufficient?
- 3. How does PBA performance scale with the amount of computation used?
- 4. How sensitive is PBA to the hyperparameters of the optimization procedure – did we just move part of the optimization process into hyperparameter selection?

# 4.1. Comparison with Baselines

Accuracy (CIFAR-10, CIFAR-100, SVHN) We first compare PBA to other state-of-the-art methods on the CIFAR-10 [\(Krizhevsky,](#page-8-0) [2009\)](#page-8-0) and SVHN [\(Netzer et al.,](#page-9-0) [2011\)](#page-9-0) datasets. Following [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0), we search over a "reduced" dataset of 4,000 and 1,000 training images for CIFAR-10 and SVHN respectively. Comparatively, CIFAR-10 has a total of 50,000 training images and SVHN has 73,257 training images with an additional 531,131 "extra" training images. PBA is run with 16 total trials on the Wide-ResNet-40-2 model to generate augmentation schedules.

For the augmentation policy, we initialize all magnitude and probability values to 0, as we hypothesize that less augmentation is required early in training when the validation accuracy is close to training accuracy. However, since training error decreases faster than validation error as training progresses, more regularization should be required, so we expect the probability and magnitude values to increase as training progresses. This would counteract overfitting as we introduce the model to more diverse data.

We then train models on the full training datasets, using the highest performing augmentation schedules discovered on the reduced datasets. The schedule learned on reduced CIFAR-10 is used to train final models on reduced CIFAR-10, CIFAR-10, and CIFAR-100. The schedule learned on reduced SVHN is used to train final models on reduced SVHN and SVHN. We report results in Table [2.](#page-5-0) Each model is evaluated five times with different random initializations, and we report both the mean and standard deviation test set error in %.

The models we evaluate on include: Wide-ResNet-28-10 [\(Zagoruyko & Komodakis,](#page-10-0) [2016\)](#page-10-0), Shake-Shake (26 2x32d) <span id="page-5-0"></span>Table 2. Test set error (%) on CIFAR-10, CIFAR-100, and SVHN. Lower is better. The baseline applies regular random crop and horizontal flip operations. Cutout is applied on top of the baseline, and PBA/AutoAugment are applied on top of Cutout. We report the mean final test error of 5 random model initializations. We used the models: Wide-ResNet-28-10 [\(Zagoruyko & Komodakis,](#page-10-0) [2016\)](#page-10-0), Shake-Shake (26 2x32d) [\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), Shake-Shake (26 2x96d) [\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), Shake-Shake (26 2x112d) [\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), and PyramidNet with ShakeDrop [\(Han et al.,](#page-8-0) [2016;](#page-8-0) [Yamada et al.,](#page-10-0) [2018\)](#page-10-0). Code for AA eval on SVHN was not released, so differences between our implementations could impact results. Thus, we report AA\* from our re-evaluation.

| Dataset          | Model                   | Baseline | Cutout | AA    | AA*          | PBA           |
|------------------|-------------------------|----------|--------|-------|--------------|---------------|
| CIFAR-10         | Wide-ResNet-28-10       | 3.87     | 3.08   | 2.68  |              | 2.58 ± 0.062  |
|                  | Shake-Shake (26 2x32d)  | 3.55     | 3.02   | 2.47  |              | 2.54 ± 0.10   |
|                  | Shake-Shake (26 2x96d)  | 2.86     | 2.56   | 1.99  |              | 2.03 ± 0.11   |
|                  | Shake-Shake (26 2x112d) | 2.82     | 2.57   | 1.89  |              | 2.03 ± 0.080  |
|                  | PyramidNet+ShakeDrop    | 2.67     | 2.31   | 1.48  |              | 1.46 ± 0.077  |
| Reduced CIFAR-10 | Wide-ResNet-28-10       | 18.84    | 17.05  | 14.13 |              | 12.82 ± 0.26  |
|                  | Shake-Shake (26 2x96d)  | 17.05    | 13.40  | 10.04 |              | 10.64 ± 0.22  |
| CIFAR-100        | Wide-ResNet-28-10       | 18.8     | 18.41  | 17.09 |              | 16.73 ± 0.15  |
|                  | Shake-Shake (26 2x96d)  | 17.05    | 16.00  | 14.28 |              | 15.31 ± 0.28  |
|                  | PyramidNet+ShakeDrop    | 13.99    | 12.19  | 10.67 |              | 10.94 ± 0.094 |
| SVHN             | Wide-ResNet-28-10       | 1.50     | 1.40   | 1.07  | 1.13 ± 0.024 | 1.18 ± 0.022  |
|                  | Shake-Shake (26 2x96d)  | 1.40     | 1.20   | 1.02  | 1.10 ± 0.032 | 1.13 ± 0.029  |
| Reduced SVHN     | Wide-ResNet-28-10       | 13.21    | 32.5   | 8.15  |              | 7.83 ± 0.22   |
|                  | Shake-Shake (26 2x96d)  | 13.32    | 24.22  | 5.92  |              | 6.46 ± 0.13   |

[\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), Shake-Shake (26 2x96d) [\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), Shake-Shake (26 2x112d) [\(Gastaldi,](#page-8-0) [2017\)](#page-8-0), and Pyramid-Net with ShakeDrop [\(Han et al.,](#page-8-0) [2016;](#page-8-0) [Yamada et al.,](#page-10-0) [2018\)](#page-10-0). PyramidNet with Shake-Drop uses a batch size of 64, and all other models use a batch size of 128. For Wide-ResNet-28-10 and Wide-ResNet-40-2 trained on SVHN, we use the step learning rate schedule proposed in [\(Devries & Taylor,](#page-8-0) [2017\)](#page-8-0), and for all others we use a cosine learning rate with one annealing cycle [\(Loshchilov & Hutter,](#page-9-0) [2016\)](#page-9-0). For all models, we use gradient clipping with magnitude 5. For specific learning rate and weight decay values, see the supplementary materials.

Additionally, we report Baseline, Cutout, and AutoAugment (AA) results found in [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0). For baseline, standard horizontal flipping and cropping augmentations were used. The training data is also normalized by the respective dataset statistics. For Cutout, a patch of size 16x16 is used for all CIFAR datasets, and size 20x20 for SVHN datasets. This applied with 100% chance to each image. AutoAugment and PBA apply additional augmentations on top of the Cutout set (note that this possibly includes a second application of Cutout). The exception is Reduced SVHN, where the first 16x16 Cutout operation is removed as it was found to reduce performance.

CIFAR-10 On Reduced CIFAR-10, we run PBA for 200 epochs, creating a policy schedule defined over 200 epochs. To extend the policy to Shake-Shake and PyramidNet models trained for 1800 epochs, we scale the length of the original schedule linearly.

While model accuracy on Reduced CIFAR-10 would have likely been improved with hyperparamater tuning for the reduced dataset size and smaller Wide-ResNet-40-2 model, our result shows that no hyperparameter tuning is required for high performance.

Overall, the PBA learned schedule leads AutoAugment slightly on PyramidNet and Wide-ResNet-28-10, and performs comparably on Shake-Shake models, showing that the learned schedule is competitive with state-of-the-art.

We visualize the discovered schedule used in training our final CIFAR models in Figure [4.](#page-6-0) For the AutoContrast, Equalize, and Invert augmentations, magnitude values were ignored. From the probability values, our schedule seems to contain all augmentations to at least a moderate degree at some point, which is reasonable given our random perturb exploration method. However, there is emphasis on Cutout, Posterize, Invert, Equalize, and AutoContrast throughout the schedule.

[\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0) suggests that color-based transformations are more useful on CIFAR compared to geometric ones, and our results also indicate this. However, they also found that the Invert transformation is almost never used, while it was very common in our schedule. A possible explanation may be that a model is able to better adapt to Invert when using a nonstationary policy. PBA may be exploring systematically different parts of the design space than AutoAugment. Alternatively, it may be that by the randomness in PBA, Cutout was introduced and impacted performance. It may be fruitful to explore combinations

<span id="page-6-0"></span>![](_page_6_Figure_1.jpeg)

**Caption:** Figure 4a depicts the evolution of operation magnitudes in the PBA schedule for CIFAR-10, showing a rapid increase in magnitudes during early training epochs, stabilizing around epoch 130. This trend indicates the adaptive nature of PBA in optimizing augmentation strategies throughout the training process.

(a) Operation magnitudes increase rapidly in the initial phase of training, eventually reaching a steady state around epoch 130.

![](_page_6_Figure_3.jpeg)

**Caption:** Figure 4b presents a normalized plot of operation probability parameters over time in the PBA schedule for CIFAR-10. The distribution flattens towards the end of training, suggesting that PBA effectively balances the application of various augmentations as training progresses, enhancing model robustness.

(b) Normalized plot of operation probability parameters over time. The distribution flattens out towards the end of training.

Figure 4. Plots showing the evolution of PBA operation parameters in the discovered schedule for CIFAR-10. Note that each operation actually appears in the parameter list twice; we take the mean parameter value for each operation in this visualization.

of PBA and AutoAugment to design nonstationary policies with more precision from a RNN Controller.

CIFAR-100 We additionally evaluate on CIFAR-100 using the same augmentation schedule discovered using Reduced CIFAR-10. We find that these results are also competitive with AutoAugment and significantly better than Baseline or only applying Cutout.

SVHN We ran PBA for 160 epochs on a 1,000 image Reduced SVHN dataset to discover an augmentation policy schedule without tuning any parameters of the algorithm. See the appendix for a visualization of an example PBA policy on the SVHN dataset.

We then trained models on both the Reduced SVHN and SVHN Full (core training data with extra data), using the discovered schedule. Except for the Wide-ResNet-28-10 model on Reduced SVHN, training was done without tuning,

![](_page_6_Figure_10.jpeg)

**Caption:** Figure 5 illustrates the expected best child test accuracy after a given number of random trials on Wide-ResNet-40-2. The results indicate that PBA outperforms random policy schedules, achieving higher accuracy with significantly fewer trials, underscoring the effectiveness of learned augmentation schedules.

Figure 5. Plot of the expected best child test accuracy after a given number of random trials on Wide-ResNet-40-2. Random policy schedules were generated by randomly selecting intervals of length between 1 and 40, and then selecting a random policy for the interval. All values were selected uniformly from the domain.

using the hyperparamters from AutoAugment. We were able to obtain a policy comparable with AutoAugment. This demonstrates the robustness of the PBA algorithm across datasets.

Examining the learned policy schedule, we observe that Cutout, Translate Y, Shear X, and Invert stand out as being present with high probability across all epochs. This fits with the findings of [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0), indicating that Invert and geometric transformations are successful in SVHN because it is important to learn invariances to these augmentations. From another perspective, all of the augmentations appear with reasonable probability at some point in the schedule, which suggests that using a preliminary strategy like AutoAugment to filter out poor performing augmentations would be an interesting direction to explore.

Computational Cost AutoAugment samples and evaluates ∼15,000 distinct augmentation policies on child models, which requires about 15000∗120 = 1.8m epochs of training. In comparison, PBA leverages PBT to learn a schedule with a population of 16 child models. PBA uses 200 epochs of training per child model, for a total of 3200 epochs, or over 500x less compute than AutoAugment.

As a second baseline, we also train 250 child models with randomly selected augmentation policies, and 250 child models with randomly selected augmentation schedules. In Figure 5, we use this data to plot the expected maximum *child model* test accuracy after a given number of random trials. As shown, it takes over 250 trials for the expected child accuracy, which is strongly correlated with final accuracy, to approach that reached by a single 16-trial PBA run. Hence, PBA still provides over an order of magnitude speedup here.

<span id="page-7-0"></span>

| Table 3. Ablation study: We evaluate models on CIFAR-10 using a fixed policy (the last policy of the PBA schedule learned on Reduced     |
|------------------------------------------------------------------------------------------------------------------------------------------|
| CIFAR-10), shuffled schedule order, and a fully collapsed schedule, comparing to results with the original PBA schedule. See Section 4.2 |
| for further explanation. We evaluate each model once, and some combinations were not evaluated due to cost considerations.               |

| Model                   | Cutout | Fixed Policy | Order-shuffled | Fully-shuffled | PBA           |
|-------------------------|--------|--------------|----------------|----------------|---------------|
| Wide-ResNet-28-10       | 3.08   | 2.76         | 2.66           | 2.89           | 2.576 ± 0.062 |
| Shake-Shake (26 2x32d)  | 3.02   | 2.73         | -              | -              | 2.54 ± 0.10   |
| Shake-Shake (26 2x96d)  | 2.56   | 2.33         | -              | -              | 2.03 ± 0.11   |
| Shake-Shake (26 2x112d) | 2.57   | 2.09         | -              | -              | 2.03 ± 0.080  |
| PyramidNet+ShakeDrop    | 2.31   | 1.55         | -              | -              | 1.46 ± 0.077  |

Real-time Overhead Since PBT trains all members of its population simultaneously, the minimal real-time overhead is just the time it takes to train one child model. In practice, there is a slight overhead from the mutation procedures triggered by PBT, but the overall search time is still small compared to the time to train the primary model. In contrast, AutoAugment leverages reinforcement-learning based techniques, in which a Recurrent Neural Network (RNN) controller is trained with the reinforcement learning algorithm Proximal Policy Optimization (PPO) [\(Schulman et al.,](#page-9-0) [2017\)](#page-9-0). Using this strategy, new augmentation policies can only be sampled and trained after the previous batch of samples has completed, so parallelization is limited to the batch size of the PPO update.

### 4.2. Does having a schedule matter?

PBA distinguishes itself from AutoAugment by learning a augmentation policy *schedule*, where the distribution of augmentation functions can vary as a function of the training epoch. To check whether a schedule contributes to performance, we try training the model using (1) the last augmentation policy of the PBA schedule as a fixed policy, (2) the augmentation schedule with the order of policies shuffled but the duration of each policy fixed, and (3) the augmentation schedule collapsed into a time-independent stationary distribution of augmentations (i.e., a policy is sampled independently for each batch of data, where each policy is weighted by its duration).

In Table 3, we see that training with the PBA Fixed Policy degrades accuracy by ∼10% percent on average, which is significantly worse than training with the full schedule. Compared to using Cutout, the fixed policy gives up ∼50% of gains on Wide-ResNet-28-10, Shake-Shake 32, and Shake-Shake 96, and ∼10% of gains on Shake-Shake 112 and PyramidNet. This shows that the augmentation schedule improves accuracy over a fixed policy, especially on smaller models.

Similarly, when we evaluated the shuffled schedules (only on Wide-ResNet-28-10), accuracy is also significantly lower, showing that a stationary distribution derived from the sched-

ule does not emulate the schedule. We hypothesize that schedule improves training by allowing "easy" augmentations in the initial phase of training while still allowing "harder" augmentations to be added later on.

## 4.3. Hyperparameter Tuning and Sensitivity

We did not tune the discrete space for magnitude or probability options to keep our policy easy to compare to AutoAugment. We have two copies of each operation, as the AutoAugment sub-policy is able to contain two copies of the same operation as well.

For the search algorithm, we lightly tuned the explore function and the distribution for count in Algorithm [1,](#page-3-0) the maximum number of augmentation functions to apply for each batch of data. While we keep the maximum value of count at 2 in line with AutoAugment's length 2 subpolicy, there may be room for performance improvement by carefully tuning the distribution.

We tried perturbation intervals of 2 and 4 once, but did not find this value to be sensitive. We also tried to run PBT for 100 epochs, but found this to slightly decrease performance when evaluated on models for 200 epochs.

It may be interesting to consider training a larger child model (e.g, Shake-Shake) for 1,800 epochs to generate a schedule over the full training duration and eliminate the need to stretch the schedule. In a similar vein, an experiment to use PBT directly on the full CIFAR-10 dataset or Wide-ResNet-28-10 model may lead to better performance, and is computationally feasible with PBA.

# 5. Conclusion

This paper introduces PBA, a novel formulation of data augmentation search which quickly and efficiently learns state-of-the-art augmentation policy schedules. PBA is simple to implement within any PBT framework, and we release the code for PBA as open source.

# <span id="page-8-0"></span>Acknowledgements

We thank Richard Liaw, Dogus Cubuk, Quoc Le, and the ICML reviewers for helpful discussion.

# References

- Antoniou, A., Storkey, A. J., and Edwards, H. A. Data augmentation generative adversarial networks. *CoRR*, abs/1711.04340, 2017.
- Bergstra, J. and Bengio, Y. Random search for hyperparameter optimization. *Journal of Machine Learning Research*, 13:281–305, 2012.
- Bergstra, J., Bardenet, R., Bengio, Y., and Kegl, B. Algo- ´ rithms for hyper-parameter optimization. In *NIPS*, 2011.
- Bowles, C., Chen, L., Guerrero, R., Bentley, P., Gunn, R. N., Hammers, A., Dickie, D. A., del C. Valdes Hern ´ andez, ´ M., Wardlaw, J. M., and Rueckert, D. Gan augmentation: Augmenting training data using generative adversarial networks. *CoRR*, abs/1810.10863, 2018.
- Ciresan, D., Meier, U., and Schmidhuber, J. Multicolumn deep neural networks for image classification. *2012 IEEE Conference on Computer Vision and Pattern Recognition*, Jun 2012. doi: 10.1109/cvpr.2012. 6248110. URL [http://dx.doi.org/10.1109/](http://dx.doi.org/10.1109/CVPR.2012.6248110) [CVPR.2012.6248110](http://dx.doi.org/10.1109/CVPR.2012.6248110).
- Clune, J., Misevic, D., Ofria, C., Lenski, R. E., Elena, S. F., and Sanjuan, R. Natural selection fails to optimize mu- ´ tation rates for long-term adaptation on rugged fitness landscapes. *PLoS Computational Biology*, 4:1145 – 1146, 2008.
- Cubuk, E. D., Zoph, B., Mane, D., Vasudevan, V., and Le, ´ Q. V. Autoaugment: Learning augmentation policies from data. *CoRR*, abs/1805.09501, 2018. URL [http:](http://arxiv.org/abs/1805.09501) [//arxiv.org/abs/1805.09501](http://arxiv.org/abs/1805.09501).
- Deng, J., Dong, W., Socher, R., Li, L., Li, K., and Fei-Fei, L. Imagenet: A large-scale hierarchical image database. In *2009 IEEE Conference on Computer Vision and Pattern Recognition*, pp. 248–255, June 2009. doi: 10.1109/ CVPR.2009.5206848.
- Devries, T. and Taylor, G. W. Improved regularization of convolutional neural networks with cutout. *CoRR*, abs/1708.04552, 2017. URL [http://arxiv.org/](http://arxiv.org/abs/1708.04552) [abs/1708.04552](http://arxiv.org/abs/1708.04552).
- DeVries, T. and Taylor, G. W. Dataset augmentation in feature space. *CoRR*, abs/1702.05538, 2017. URL <https://arxiv.org/abs/1702.05538>.
- Frid-Adar, M., Klang, E., Amitai, M., Goldberger, J., and Greenspan, H. Synthetic data augmentation using gan for improved liver lesion classification. *2018 IEEE 15th International Symposium on Biomedical Imaging (ISBI 2018)*, pp. 289–293, 2018.
- Gastaldi, X. Shake-shake regularization. *CoRR*, abs/1705.07485, 2017. URL [http://arxiv.org/](http://arxiv.org/abs/1705.07485) [abs/1705.07485](http://arxiv.org/abs/1705.07485).
- Golovin, D., Solnik, B., Moitra, S., Kochanski, G., Karro, J. E., and Sculley, D. (eds.). *Google Vizier: A Service for Black-Box Optimization*, 2017. URL [https://research.google.com/pubs/](https://research.google.com/pubs/archive/46180.pdf) [archive/46180.pdf](https://research.google.com/pubs/archive/46180.pdf).
- Gonzalez, J., Dai, Z., Hennig, P., and Lawrence, N. D. Batch ´ bayesian optimization via local penalization. In *AISTATS*, 2016.
- Graham, B. Fractional max-pooling. *CoRR*, abs/1412.6071, 2014. URL [http://arxiv.org/abs/1412.](http://arxiv.org/abs/1412.6071) [6071](http://arxiv.org/abs/1412.6071).
- Han, D., Kim, J., and Kim, J. Deep pyramidal residual networks. *CoRR*, abs/1610.02915, 2016. URL [http:](http://arxiv.org/abs/1610.02915) [//arxiv.org/abs/1610.02915](http://arxiv.org/abs/1610.02915).
- He, K., Zhang, X., Ren, S., and Sun, J. Deep residual learning for image recognition. *CoRR*, abs/1512.03385, 2015. URL <http://arxiv.org/abs/1512.03385>.
- He, K., Zhang, X., Ren, S., and Sun, J. Identity mappings in deep residual networks. *CoRR*, abs/1603.05027, 2016. URL <http://arxiv.org/abs/1603.05027>.
- Huang, G., Liu, Z., and Weinberger, K. Q. Densely connected convolutional networks. *CoRR*, abs/1608.06993, 2016. URL [http://arxiv.org/abs/1608.](http://arxiv.org/abs/1608.06993) [06993](http://arxiv.org/abs/1608.06993).
- Hutter, F., Hoos, H. H., and Leyton-Brown, K. Sequential model-based optimization for general algorithm configuration. In *LION*, 2011.
- Inoue, H. Data augmentation by pairing samples for images classification. *CoRR*, abs/1801.02929, 2018. URL [http:](http://arxiv.org/abs/1801.02929) [//arxiv.org/abs/1801.02929](http://arxiv.org/abs/1801.02929).
- Jaderberg, M., Dalibard, V., Osindero, S., Czarnecki, W. M., Donahue, J., Razavi, A., Vinyals, O., Green, T., Dunning, I., Simonyan, K., Fernando, C., and Kavukcuoglu, K. Population based training of neural networks. *CoRR*, abs/1711.09846, 2017. URL [http://arxiv.org/](http://arxiv.org/abs/1711.09846) [abs/1711.09846](http://arxiv.org/abs/1711.09846).
- Krizhevsky, A. Learning multiple layers of features from tiny images. Tech Report, 2009.
- <span id="page-9-0"></span>Krizhevsky, A., Sutskever, I., and Hinton, G. E. Imagenet classification with deep convolutional neural networks. In *NIPS*, 2012.
- Lemley, J., Bazrafkan, S., and Corcoran, P. Smart augmentation - learning an optimal data augmentation strategy. *CoRR*, abs/1703.08383, 2017. URL [http://arxiv.](http://arxiv.org/abs/1703.08383) [org/abs/1703.08383](http://arxiv.org/abs/1703.08383).
- Li, L., Jamieson, K. G., DeSalvo, G., Rostamizadeh, A., and Talwalkar, A. Efficient hyperparameter optimization and infinitely many armed bandits. *CoRR*, abs/1603.06560, 2016. URL [http://arxiv.org/](http://arxiv.org/abs/1603.06560) [abs/1603.06560](http://arxiv.org/abs/1603.06560).
- Lin, M., Chen, Q., and Yan, S. Network in network. *CoRR*, abs/1312.4400, 2013. URL [http://arxiv.org/](http://arxiv.org/abs/1312.4400) [abs/1312.4400](http://arxiv.org/abs/1312.4400).
- Loshchilov, I. and Hutter, F. SGDR: stochastic gradient descent with restarts. *CoRR*, abs/1608.03983, 2016. URL <http://arxiv.org/abs/1608.03983>.
- Moritz, P., Nishihara, R., Wang, S., Tumanov, A., Liaw, R., Liang, E., Paul, W., Jordan, M. I., and Stoica, I. Ray: A distributed framework for emerging AI applications. *CoRR*, abs/1712.05889, 2017. URL [http://arxiv.](http://arxiv.org/abs/1712.05889) [org/abs/1712.05889](http://arxiv.org/abs/1712.05889).
- Mundhenk, T. N., Ho, D., and Chen, B. Y. Improvements to context based self-supervised learning. *CoRR*, abs/1711.06379, 2017. URL [http://arxiv.org/](http://arxiv.org/abs/1711.06379) [abs/1711.06379](http://arxiv.org/abs/1711.06379).
- Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Y Ng, A. Reading digits in natural images with unsupervised feature learning. *NIPS*, 01 2011.
- Okafor, E., Schomaker, L., and Wiering, M. An analysis of rotation matrix and colour constancy data augmentation in classifying images of animals. *Journal of Information and Telecommunication*, 2:1–27, 06 2018. doi: 10.1080/ 24751839.2018.1479932.
- Paschali, M., Simson, W., Guha Roy, A., Ferjad Naeem, M., Gbl, R., Wachinger, C., and Navab, N. Data augmentation with manifold exploring geometric transformations for increased performance and robustness. *CoRR*, abs/1901.04420, 01 2019.
- Pham, H., Guan, M. Y., Zoph, B., Le, Q. V., and Dean, J. Efficient neural architecture search via parameter sharing. *CoRR*, abs/1802.03268, 2018. URL [http://arxiv.](http://arxiv.org/abs/1802.03268) [org/abs/1802.03268](http://arxiv.org/abs/1802.03268).
- Ratner, A. J., Ehrenberg, H. R., Hussian, Z., Dunnmon, J., and Re, C. Learning to compose domainspecific transformations for data augmentation. *NIPS*,

abs/1709.01643, 2017. URL [https://arxiv.org/](https://arxiv.org/abs/1709.01643) [abs/1709.01643](https://arxiv.org/abs/1709.01643).

- Sato, I., Nishimura, H., and Yokoi, K. Apac: Augmented pattern classification with neural networks, 2015.
- Schulman, J., Wolski, F., Dhariwal, P., Radford, A., and Klimov, O. Proximal policy optimization algorithms. *CoRR*, abs/1707.06347, 2017. URL [http://arxiv.](http://arxiv.org/abs/1707.06347) [org/abs/1707.06347](http://arxiv.org/abs/1707.06347).
- Shah, A. and Ghahramani, Z. Parallel predictive entropy search for batch global optimization of expensive objective functions. *CoRR*, abs/1511.07130, 2015. URL <http://arxiv.org/abs/1511.07130>.
- Simard, P., Steinkraus, D., and Platt, J. Best practices for convolutional neural networks applied to visual document analysis. *Seventh International Conference on Document Analysis and Recognition, 2003. Proceedings.*, 2003. doi: 10.1109/icdar.2003.1227801. URL [http://dx.doi.](http://dx.doi.org/10.1109/ICDAR.2003.1227801) [org/10.1109/ICDAR.2003.1227801](http://dx.doi.org/10.1109/ICDAR.2003.1227801).
- Simonyan, K. and Zisserman, A. Very deep convolutional networks for large-scale image recognition. *CoRR*, abs/1409.1556, 2014. URL [http://arxiv.org/](http://arxiv.org/abs/1409.1556) [abs/1409.1556](http://arxiv.org/abs/1409.1556).
- Snoek, J., Larochelle, H., and Adams, R. P. Practical bayesian optimization of machine learning algorithms. In *NIPS*, 2012.
- Springenberg, J. T., Klein, A., Falkner, S., and Hutter, F. Bayesian optimization with robust bayesian neural networks. In *NIPS*, 2016.
- Srinivas, N., Krause, A., Kakade, S. M., and Seeger, M. W. Gaussian process bandits without regret: An experimental design approach. *CoRR*, abs/0912.3995, 2009. URL <http://arxiv.org/abs/0912.3995>.
- Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., Erhan, D., Vanhoucke, V., and Rabinovich, A. Going deeper with convolutions. In *Computer Vision and Pattern Recognition (CVPR)*, 2015. URL <http://arxiv.org/abs/1409.4842>.
- Tran, T., Pham, T., Carneiro, G., Palmer, L. J., and Reid, I. D. A bayesian data augmentation approach for learning deep models. *CoRR*, abs/1710.10564, 2017. URL [http:](http://arxiv.org/abs/1710.10564) [//arxiv.org/abs/1710.10564](http://arxiv.org/abs/1710.10564).
- Wan, L., Zeiler, M. D., Zhang, S., LeCun, Y., and Fergus, R. Regularization of neural networks using dropconnect. In *ICML*, 2013.
- Wong, S. C., Gatt, A., Stamatescu, V., and McDonnell, M. D. Understanding data augmentation for classification:

<span id="page-10-0"></span>when to warp? *CoRR*, abs/1609.08764, 2016. URL <http://arxiv.org/abs/1609.08764>.

- Yamada, Y., Iwamura, M., and Kise, K. Shakedrop regularization. *CoRR*, abs/1802.02375, 2018. URL [http:](http://arxiv.org/abs/1802.02375) [//arxiv.org/abs/1802.02375](http://arxiv.org/abs/1802.02375).
- Zagoruyko, S. and Komodakis, N. Wide residual networks. *CoRR*, abs/1605.07146, 2016. URL [http://arxiv.](http://arxiv.org/abs/1605.07146) [org/abs/1605.07146](http://arxiv.org/abs/1605.07146).
- Zoph, B. and Le, Q. V. Neural architecture search with reinforcement learning. *CoRR*, abs/1611.01578, 2016. URL <http://arxiv.org/abs/1611.01578>.
- Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. Learning transferable architectures for scalable image recognition. *CoRR*, abs/1707.07012, 2017. URL [http://arxiv.](http://arxiv.org/abs/1707.07012) [org/abs/1707.07012](http://arxiv.org/abs/1707.07012).

![](_page_11_Figure_1.jpeg)

**Caption:** Figure 6 compares the relative cost of search to test accuracy for augmentation policies evaluated on Wide-ResNet-28-10. The results demonstrate that a population size of 16 models yields optimal performance, emphasizing the importance of population size in effectively exploring the augmentation policy search space.

Figure 6. Comparison of relative cost of search to test accuracy of augmentation policies evaluated on WideResNet-28-10. Child model WRN-40-2 was evaluated for population sizes from 2 to 64, and ResNet-20 was evaluated for sizes 2 to 32. All policies were trained on Reduced CIFAR-10.

# A. PBA Scalability with Compute

In Figure 6 we look at how large the model and PBT population size is necessary to learn an effective schedule. The population size determines how much of the search space is explored during training, and also the computational overhead of PBA. Our results indicate that a population size of 16 WRN-40-2 models performs the best. Having more than 16 trials seems not to help, and having less than 16 seems to lead to decreased performance. However, we found that results could fluctuate significantly between runs of PBT, most likely due to exploring a very limited search space with a noisy exploration strategy.

Besides WRN-40-2, we also tried to use a ResNet-20 [\(He](#page-8-0) [et al.,](#page-8-0) [2016\)](#page-8-0) model for PBT population, which required about half the compute. Empirical results (in Table [4](#page-12-0) and Figure 6) suggest that the ResNet-20 population does not achieve as high of a test accuracy as with WRN-40-2, but results were relatively close. Because a ResNet-20 model has much less parameters, training accuracy plateaus faster than WRN-40-2, which may change the effects of augmentation.

# B. Model Hyperparameters

The hyperparameters used to train WideResNet-40-2 to discover augmentation schedules, and also the ones used to train final models, are displayed in Table [5.](#page-12-0) For full details on the hyperparameters and implementation, see the open source code.

![](_page_11_Figure_8.jpeg)

**Caption:** Figure 7 showcases augmentations applied to a '4' class image from the SVHN dataset at various points in the learned PBA schedule. Each operation is detailed with its name, probability, and magnitude, illustrating the dynamic nature of augmentations tailored to enhance model performance throughout training.

Figure 7. Augmentations applied to a SVHN "4" class image, at various points in our augmentation schedule learned on Reduced SVHN data. Each operation is formatted with name, probability, and magnitude value respectively.

# C. SVHN discovered schedule

See Figure 7 for a visualization of the policy on an example image and Figure [8](#page-13-0) for a visualization of an example PBA policy on the SVHN dataset.

Examining the learned policy schedule, we observe that Cutout, Translate Y, Shear X, and Invert stand out as being present with high probability across all epochs. This fits with the findings of [\(Cubuk et al.,](#page-8-0) [2018\)](#page-8-0) indicating that Invert and geometric transformations are successful in SVHN because it is important to learn invariances to these augmentations. From another perspective, all of the augmentations appear with reasonable probability at some point in the schedule, which suggests that using a preliminary strategy like AutoAugment to filter out poor performing augmentations would be an interesting direction to explore.

<span id="page-12-0"></span>Table 4. Test error during PBT search and policy schedule evaluated afterwards, for varying population sizes and models. PBA Search with variation of model and compute, on Reduced CIFAR-10 dataset. ResNet-20 (Res) took approximately half the compute of WideResNet-40-2 (WRN). Number in title is the population size, and speedup is relative to AutoAugment. Note that models with larger population sizes, while scoring high during the search, don't actually perform better when re-evaluated.

| Model                   | 8-Res  | 16-Res | 32-Res | 16-WRN | 32-WRN  | 64-WRN   |
|-------------------------|--------|--------|--------|--------|---------|----------|
| WRN-40-2 during search  | -      | -      | -      | 0.8484 | 0.8446  | 0.8523   |
| WRN-40-2                | -      | -      | -      | 0.8452 | 0.8445  | 0.8446   |
| ResNet-20 during search | 0.7484 | 0.7657 | 0.7619 | -      | -       | -        |
| ResNet-20               | 0.7457 | 0.7545 | 0.7534 | -      | -       | -        |
| WRN-28-10               | 0.9711 | 0.9721 | 0.9740 | 0.9740 | 0.9736  | 0.9703   |
| Relative Speedup        | 2250x  | 1125x  | 562.5x | 562.5x | 281.25x | 140.625x |

Table 5. Hyperparameters used for evaluation on CIFAR-10, CIFAR-100, and (R)educed-CIFAR-10. Besides Wide-ResNet-28-10 and Wide-ResNet-40-2 on Reduced SVHN, no hyperparameter tuning was done. Instead, all hyperparameters are the same as those used in AutoAugment.

| Dataset    | Model                   | Learning Rate | Weight Decay | Batch Size |
|------------|-------------------------|---------------|--------------|------------|
| CIFAR-10   | Wide-ResNet-40-2        | 0.1           | 0.0005       | 128        |
| CIFAR-10   | Wide-ResNet-28-10       | 0.1           | 0.0005       | 128        |
| CIFAR-10   | Shake-Shake (26 2x32d)  | 0.01          | 0.001        | 128        |
| CIFAR-10   | Shake-Shake (26 2x96d)  | 0.01          | 0.001        | 128        |
| CIFAR-10   | Shake-Shake (26 2x112d) | 0.01          | 0.001        | 128        |
| CIFAR-10   | PyramidNet+ShakeDrop    | 0.05          | 0.00005      | 64         |
| CIFAR-100  | Wide-ResNet-28-10       | 0.1           | 0.0005       | 128        |
| CIFAR-100  | Shake-Shake (26 2x96d)  | 0.01          | 0.0025       | 128        |
| CIFAR-100  | PyramidNet+ShakeDrop    | 0.025         | 0.0005       | 64         |
| R-CIFAR-10 | Wide-ResNet-28-10       | 0.05          | 0.005        | 128        |
| R-CIFAR-10 | Shake-Shake (26 2x96d)  | 0.025         | 0.0025       | 128        |
| SVHN       | Wide-ResNet-40-2        | 0.05          | 0.005        | 128        |
| SVHN       | Wide-ResNet-28-10       | 0.005         | 0.001        | 128        |
| SVHN       | Shake-Shake (26 2x96d)  | 0.01          | 0.00015      | 128        |
| R-SVHN     | Wide-ResNet-28-10       | 0.05          | 0.01         | 128        |
| R-SVHN     | Shake-Shake (26 2x96d)  | 0.025         | 0.005        | 128        |

<span id="page-13-0"></span>![](_page_13_Figure_1.jpeg)

**Caption:** Figure 8 visualizes the evolution of operation parameters in the PBA schedule learned on Reduced SVHN. The plot indicates how each operation's parameters are adjusted over time, reflecting PBA's capability to optimize augmentation strategies effectively during the training process.

(b) Normalized plot of operation probability parameters over time.

Figure 8. Plots showing the evolution of PBA operation parameters in a schedule learned on Reduced SVHN. Note that each operation actually appears in the parameter list twice; we take the mean parameter value for each operation in this visualization.